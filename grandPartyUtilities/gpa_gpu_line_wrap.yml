###############################################################################
#                                                                             #
#                      GRANDPARTYUTILITIES: LINE WRAPPER                      #
#                                                                             #
###############################################################################
# 
# This script does not require "gpa_gpu_main.yml" to work. It should work
# across all versions, although the latest version of Denizen and Spigot are
# recommended for optimal performance.
# 
# 
# ----| ABOUT THIS SCRIPT
# 
# This script takes a string and splits it into multiple lines respecting a
# certain character length. Any number of characters can be specified per line,
# and a maximum number of lines can be chosen.
# 
# 
# ----| HOW TO USE
# 
# To use this script, use it as a procedure tag:
# 
#   - <proc[gpa_gpu_line_wrap].context[string|max_length|max_lines]>
# 
# The procedure will return a dList of the lines. The player may then perform
# any operation on the dList as they see fit.
# 
# The definitions are as follows:
# 
#   string      : The escaped string the player wants to line wrap.
#                 Color codes will not be automatically parsed. They need to be
#                 converted into a tag (e.g. "<&a>" instead of "&a").
#   max_length  : The maximum number of characters per line. If the number is
#                 smaller than the length of the smallest word in the string,
#                 then the entire string will be returned without any wrapping.
#   max_lines   : The maximum number of lines the script will attempt to wrap.
#                 Any word past the limit will be excluded and an ellipses
#                 will be put at the end.
#                 This must be at least 1.
#
#

gpa_gpu_line_wrap:
  type: procedure
  speed: 0
  debug: false
  definitions: string|max_length|max_lines
  script:
  - define cl_str '<def[string].split_by[ ]||li@>'
  - define final_str 'li@'
  - if <def[cl_str].is_empty> {
    - goto skip_line_split
  }
  - if <def[cl_str].space_separated.unescaped.length> <= <def[max_length]>
    || <def[cl_str].parse[unescaped.length].numerical.get[1]> > <def[max_length]> {
    - define final_str 'li@<def[cl_str].space_separated>'
    - goto skip_line_split
  }

  - define fl '<def[cl_str].space_separated>'
  - define ind '0'
  - define dlc '<&f>'
  - while <def[fl].unescaped.length.is[MORE].than[0]||false> {
    - define string_op '<def[lc]||<def[dlc]>><def[fl].unescaped.substring[1,<def[max_length]>]>'
    - if <def[string_op].index_of[<&nl>]||-1> != -1 {
      - define string_op '<def[string_op].before[<&nl>]>'
    }
    - define list_op '<def[string_op].split[ ]>'
    - define ind '<def[ind].add[<def[list_op].size>]>'
    - if <def[cl_str].get[<def[ind]||last>].unescaped> != <def[list_op].last.unescaped> {
      - define string_op '<def[string_op].before_last[ ]>'
    }
    - if <def[loop_index]> >= <def[max_lines].max[1]||999> {
      - if <def[fl].length> > <def[max_length]> {
        - define string_op '<def[lc]||<def[dlc]>><def[fl].unescaped.substring[0,<def[max_length].sub[3]>]>'
        - define list_op '<def[string_op].split[ ]>'
        - if <def[cl_str].get[<def[list_op].size>]> != <def[list_op].last> {
          - define string_op '<def[string_op].before_last[ ]>'
        }
        - define string_op '<def[string_op]>...'
      }
      - define final_str '<def[red].include[<def[string_op]>]>'
      - while stop
    }
    - define final_str '<def[red].include[<def[string_op]>]>'
    - define fl '<def[fl].substring[<def[string_op].unescaped.length.sub_int[1]>].trim>'
    - define lc '<def[string_op].unescaped.last_color||<def[dlc]>>'
  }

  - mark skip_line_split
  - determine <def[final_str]>
